(poly_expr
 (eval_TCC1 0
  (eval_TCC1-1 nil 3714898997 ("" (termination-tcc) nil nil)
   ((<< adt-def-decl "(strict_well_founded?[PolyExpr])" PolyExpr_adt
     nil))
   nil))
 (eval_TCC2 0
  (eval_TCC2-1 nil 3714898997 ("" (termination-tcc) nil nil)
   ((<< adt-def-decl "(strict_well_founded?[PolyExpr])" PolyExpr_adt
     nil))
   nil))
 (eval_TCC3 0
  (eval_TCC3-1 nil 3714898997 ("" (termination-tcc) nil nil)
   ((<< adt-def-decl "(strict_well_founded?[PolyExpr])" PolyExpr_adt
     nil))
   nil))
 (eval_TCC4 0
  (eval_TCC4-1 nil 3714898997 ("" (termination-tcc) nil nil)
   ((<< adt-def-decl "(strict_well_founded?[PolyExpr])" PolyExpr_adt
     nil))
   nil))
 (eval_TCC5 0
  (eval_TCC5-1 nil 3714898997 ("" (termination-tcc) nil nil)
   ((<< adt-def-decl "(strict_well_founded?[PolyExpr])" PolyExpr_adt
     nil))
   nil))
 (eval_TCC6 0
  (eval_TCC6-1 nil 3714898997 ("" (termination-tcc) nil nil)
   ((<< adt-def-decl "(strict_well_founded?[PolyExpr])" PolyExpr_adt
     nil))
   nil))
 (eval_TCC7 0
  (eval_TCC7-1 nil 3714898997 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (> const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (<< adt-def-decl "(strict_well_founded?[PolyExpr])" PolyExpr_adt
     nil))
   nil))
 (eval_TCC8 0
  (eval_TCC8-1 nil 3714898997 ("" (subtype-tcc) nil nil)
   ((/= const-decl "boolean" notequal nil)) nil))
 (dx_TCC1 0
  (dx_TCC1-1 nil 3714918446 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (> const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil))
 (test 0
       (test-1 nil 3715013301
        ("" (decompose-equality) (("" (grind) nil nil)) nil)
        ((expt def-decl "real" exponentiation nil)
         (^ const-decl "real" exponentiation nil)
         (real_ge_is_total_order name-judgement "(total_order?[real])"
          real_props nil)
         (real_plus_real_is_real application-judgement "real" reals
          nil)
         (real_times_real_is_real application-judgement "real" reals
          nil)
         (real_minus_real_is_real application-judgement "real" reals
          nil)
         (number nonempty-type-decl nil numbers nil)
         (boolean nonempty-type-decl nil booleans nil)
         (number_field_pred const-decl "[number -> boolean]"
          number_fields nil)
         (number_field nonempty-type-from-decl nil number_fields nil)
         (real_pred const-decl "[number_field -> boolean]" reals nil)
         (real nonempty-type-from-decl nil reals nil)
         (MUL adt-constructor-decl
          "[[PolyExpr, PolyExpr] -> (multiplication?)]" PolyExpr_adt
          nil)
         (multiplication? adt-recognizer-decl "[PolyExpr -> boolean]"
          PolyExpr_adt nil)
         (CONST adt-constructor-decl "[real -> (constant?)]"
          PolyExpr_adt nil)
         (constant? adt-recognizer-decl "[PolyExpr -> boolean]"
                    PolyExpr_adt nil)
         (X adt-constructor-decl "(variable?)" PolyExpr_adt nil)
         (variable? adt-recognizer-decl "[PolyExpr -> boolean]"
                    PolyExpr_adt nil)
         (ADD adt-constructor-decl
          "[[PolyExpr, PolyExpr] -> (addition?)]" PolyExpr_adt nil)
         (addition? adt-recognizer-decl "[PolyExpr -> boolean]"
          PolyExpr_adt nil)
         (POW adt-constructor-decl "[[PolyExpr, posnat] -> (power?)]"
          PolyExpr_adt nil)
         (power? adt-recognizer-decl "[PolyExpr -> boolean]"
          PolyExpr_adt nil)
         (posnat nonempty-type-eq-decl nil integers nil)
         (> const-decl "bool" reals nil)
         (nonneg_int nonempty-type-eq-decl nil integers nil)
         (>= const-decl "bool" reals nil)
         (bool nonempty-type-eq-decl nil booleans nil)
         (int nonempty-type-eq-decl nil integers nil)
         (integer_pred const-decl "[rational -> boolean]" integers nil)
         (rational nonempty-type-from-decl nil rationals nil)
         (rational_pred const-decl "[real -> boolean]" rationals nil)
         (SUB adt-constructor-decl
          "[[PolyExpr, PolyExpr] -> (subtraction?)]" PolyExpr_adt nil)
         (subtraction? adt-recognizer-decl "[PolyExpr -> boolean]"
          PolyExpr_adt nil)
         (dx def-decl "PolyExpr" poly_expr nil)
         (eval def-decl "real" poly_expr nil)
         (PolyExpr type-decl nil PolyExpr_adt nil))
        shostak))
 (eval_continuous_TCC1 0
  (eval_continuous_TCC1-1 nil 3714905106
   ("" (recursive-judgement-tcc) nil nil)
   ((/= const-decl "boolean" notequal nil)
    (real_minus_real_is_real application-judgement "real" reals nil))
   nil))
 (eval_continuous_TCC2 0
  (eval_continuous_TCC2-1 nil 3714905106
   ("" (skeep)
    (("" (use "PolyExpr_inclusive")
      (("" (split -1)
        (("1" (assert)
          (("1" (hide -1) (("1" (use "const_cont") nil nil)) nil)) nil)
         ("2" (assert)
          (("2" (hide -1) (("2" (use "id_cont") nil nil)) nil)) nil)
         ("3" (assert)
          (("3" (hide -1)
            (("3" (typepred "v(expr1(pexpr))")
              (("3" (typepred "v(expr2(pexpr))")
                (("3" (use "add_cont")
                  (("1" (hide -2 2) (("1" (grind) nil nil)) nil)
                   ("2" (hide -1 2) (("2" (grind) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("4" (assert)
          (("4" (hide -1)
            (("4" (typepred "v(expr1(pexpr))")
              (("4" (typepred "v(expr2(pexpr))")
                (("4" (use "sub_cont")
                  (("1" (hide -2 2) (("1" (grind) nil nil)) nil)
                   ("2" (hide -1 2) (("2" (grind) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("5" (assert)
          (("5" (hide -1)
            (("5" (typepred "v(expr1(pexpr))")
              (("5" (typepred "v(expr2(pexpr))")
                (("5" (use "mult_cont")
                  (("1" (hide -2 2) (("1" (grind) nil nil)) nil)
                   ("2" (hide -1 2) (("2" (grind) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("6" (assert)
          (("6" (hide -1)
            (("6" (typepred "v(expr(pexpr))")
              (("6" (use "pow_cont")
                (("6" (hide 2) (("6" (grind) nil nil)) nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((PolyExpr_inclusive formula-decl nil PolyExpr_adt nil)
    (PolyExpr type-decl nil PolyExpr_adt nil)
    (expr adt-accessor-decl "[(power?) -> PolyExpr]" PolyExpr_adt nil)
    (power? adt-recognizer-decl "[PolyExpr -> boolean]" PolyExpr_adt
     nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (expo adt-accessor-decl "[(power?) -> posnat]" PolyExpr_adt nil)
    (pow_cont formula-decl nil continuous_lambda "analysis/")
    (mult_cont formula-decl nil continuous_lambda "analysis/")
    (sub_cont formula-decl nil continuous_lambda "analysis/")
    (expr1 shared-adt-accessor-decl
     "[{x: PolyExpr | addition?(x) OR subtraction?(x) OR multiplication?(x)} ->
   PolyExpr]" PolyExpr_adt nil)
    (multiplication? adt-recognizer-decl "[PolyExpr -> boolean]"
     PolyExpr_adt nil)
    (subtraction? adt-recognizer-decl "[PolyExpr -> boolean]"
     PolyExpr_adt nil)
    (addition? adt-recognizer-decl "[PolyExpr -> boolean]" PolyExpr_adt
     nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (continuous_fun nonempty-type-eq-decl nil continuous_functions
     "analysis/")
    (continuous? const-decl "bool" continuous_functions "analysis/")
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (add_cont formula-decl nil continuous_lambda "analysis/")
    (pexpr skolem-const-decl "PolyExpr" poly_expr nil)
    (v skolem-const-decl "[PolyExpr -> continuous_fun[real]]" poly_expr
     nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs
         nil)
    (continuous? const-decl "bool" continuous_functions "analysis/")
    (expr2 shared-adt-accessor-decl
     "[{x: PolyExpr | addition?(x) OR subtraction?(x) OR multiplication?(x)} ->
   PolyExpr]" PolyExpr_adt nil)
    (id_cont formula-decl nil continuous_lambda "analysis/")
    (val adt-accessor-decl "[(constant?) -> real]" PolyExpr_adt nil)
    (constant? adt-recognizer-decl "[PolyExpr -> boolean]" PolyExpr_adt
               nil)
    (const_cont formula-decl nil continuous_lambda "analysis/")
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil))
   nil))
 (IMP_derivatives_lam_TCC1 0
  (IMP_derivatives_lam_TCC1-1 nil 3714918122 ("" (assert) nil nil)
   ((deriv_domain_real formula-decl nil deriv_domain "analysis/"))
   nil))
 (IMP_derivatives_lam_TCC2 0
  (IMP_derivatives_lam_TCC2-1 nil 3714918122 ("" (assert) nil nil)
   ((not_one_element_real formula-decl nil deriv_domain "analysis/"))
   nil))
 (eval_differentiable_TCC1 0
  (eval_differentiable_TCC1-1 nil 3714909150
   ("" (recursive-judgement-tcc) nil nil)
   ((/= const-decl "boolean" notequal nil)) nil))
 (eval_differentiable_TCC2 0
  (eval_differentiable_TCC2-2 nil 3714909195
   ("" (skeep)
    (("" (use "PolyExpr_inclusive")
      (("" (split -1)
        (("1" (assert) (("1" (use "derivable_const_lam") nil nil)) nil)
         ("2" (assert)
          (("2" (hide -1) (("2" (use "derivable_id_lam") nil nil))
            nil))
          nil)
         ("3" (assert)
          (("3" (hide -1)
            (("3" (typepred "v(expr1(pexpr))")
              (("3" (typepred "v(expr2(pexpr))")
                (("3" (use "derivable_add_lam")
                  (("1" (hide -2 2) (("1" (grind) nil nil)) nil)
                   ("2" (hide -1 2) (("2" (grind) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("4" (assert)
          (("4" (hide -1)
            (("4" (typepred "v(expr1(pexpr))")
              (("4" (typepred "v(expr2(pexpr))")
                (("4" (use "derivable_sub_lam")
                  (("1" (hide -2 2) (("1" (grind) nil nil)) nil)
                   ("2" (hide -1 2) (("2" (grind) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("5" (assert)
          (("5" (hide -1)
            (("5" (typepred "v(expr1(pexpr))")
              (("5" (typepred "v(expr2(pexpr))")
                (("5" (use "derivable_mult_lam")
                  (("1" (hide -2 2) (("1" (grind) nil nil)) nil)
                   ("2" (hide -1 2) (("2" (grind) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("6" (assert)
          (("6" (hide -1)
            (("6" (typepred "v(expr(pexpr))")
              (("6" (lemma "comp_derivable_fun")
                (("6"
                  (inst -1 "v(expr(pexpr))"
                   "LAMBDA(x:real):x^expo(pexpr)")
                  (("1" (assert)
                    (("1" (hide -1 2)
                      (("1" (use "derivable_pow_lam") nil nil)) nil))
                    nil)
                   ("2" (hide -1 2)
                    (("2" (skeep) (("2" (assert) nil nil)) nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((PolyExpr_inclusive formula-decl nil PolyExpr_adt nil)
    (PolyExpr type-decl nil PolyExpr_adt nil)
    (expr adt-accessor-decl "[(power?) -> PolyExpr]" PolyExpr_adt nil)
    (power? adt-recognizer-decl "[PolyExpr -> boolean]" PolyExpr_adt
     nil)
    (expo adt-accessor-decl "[(power?) -> posnat]" PolyExpr_adt nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (>= const-decl "bool" reals nil)
    (/= const-decl "boolean" notequal nil)
    (^ const-decl "real" exponentiation nil)
    (derivable_pow_lam formula-decl nil derivatives_lam "analysis/")
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (comp_derivable_fun formula-decl nil chain_rule "analysis/")
    (derivable_mult_lam formula-decl nil derivatives_lam "analysis/")
    (derivable_sub_lam formula-decl nil derivatives_lam "analysis/")
    (expr1 shared-adt-accessor-decl
     "[{x: PolyExpr | addition?(x) OR subtraction?(x) OR multiplication?(x)} ->
   PolyExpr]" PolyExpr_adt nil)
    (multiplication? adt-recognizer-decl "[PolyExpr -> boolean]"
     PolyExpr_adt nil)
    (subtraction? adt-recognizer-decl "[PolyExpr -> boolean]"
     PolyExpr_adt nil)
    (addition? adt-recognizer-decl "[PolyExpr -> boolean]" PolyExpr_adt
     nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (deriv_fun type-eq-decl nil derivatives "analysis/")
    (derivable? const-decl "bool" derivatives "analysis/")
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (derivable_add_lam formula-decl nil derivatives_lam "analysis/")
    (pexpr skolem-const-decl "PolyExpr" poly_expr nil)
    (v skolem-const-decl "[PolyExpr -> deriv_fun[real]]" poly_expr nil)
    (real_div_nzreal_is_real application-judgement "real" reals nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (fullset const-decl "set" sets nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs
         nil)
    (adh const-decl "setof[real]" convergence_functions "analysis/")
    (NQ const-decl "real" derivatives_def "analysis/")
    (convergence const-decl "bool" convergence_functions "analysis/")
    (convergence const-decl "bool" lim_of_functions "analysis/")
    (convergent? const-decl "bool" lim_of_functions "analysis/")
    (derivable? const-decl "bool" derivatives_def "analysis/")
    (expr2 shared-adt-accessor-decl
     "[{x: PolyExpr | addition?(x) OR subtraction?(x) OR multiplication?(x)} ->
   PolyExpr]" PolyExpr_adt nil)
    (derivable_id_lam formula-decl nil derivatives_lam "analysis/")
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (derivable_const_lam formula-decl nil derivatives_lam "analysis/")
    (constant? adt-recognizer-decl "[PolyExpr -> boolean]" PolyExpr_adt
               nil)
    (val adt-accessor-decl "[(constant?) -> real]" PolyExpr_adt nil))
   nil))
 (eval_derivative 0
  (eval_derivative-1 nil 3714918193
   (""
    (deftactic dd (nm)
     (let ((lem (format nil "deriv_~a_lam" nm)))
       (then (skeep) (decompose-equality 1) (expand "dx" 1)
        (expand "eval" 1) (use lem) (replaces -1) (assert))))
    ((""
      (deftactic dd2 (nm)
       (let ((lem (format nil "deriv_~a_lam" nm)))
         (with-fresh-names ((x1) (x2))
          (let ((ev1 (format nil "eval(~a)" x1))
                (ev2 (format nil "eval(~a)" x2)))
            (then (skolem 1 (x1 x2)) (flatten) (decompose-equality 1)
             (expand "dx" 1) (expand "eval" 1)
             (spread (use lem)
              ((then (replaces -) (assert) (lemma "eta[real,real]")
                (inst-cp -1 ev1) (inst -1 ev2) (replaces -))
               (then (hide-all-but 1) (lemma "eta[real,real]")
                (inst -1 ev2) (replaces -1) (assert))
               (then (hide-all-but 1) (lemma "eta[real,real]")
                (inst -1 ev1) (replaces -1) (assert)))))))))
      (("" (induct "pexpr")
        (("1" (dd "const") nil nil) ("2" (dd "id") nil nil)
         ("3" (dd2 "add") nil nil) ("4" (dd2 "sub") nil nil)
         ("5" (skolem 1 ("x1" "x2"))
          (("5" (flatten)
            (("5" (decompose-equality 1)
              (("5" (expand "dx" 1)
                (("5" (expand "eval" 1)
                  (("5" (expand "eval" 1 1)
                    (("5" (expand "eval" 1 1)
                      (("5" (use "deriv_mult_lam")
                        (("1" (replaces -)
                          (("1" (assert)
                            (("1" (lemma "eta[real,real]")
                              (("1"
                                (inst-cp -1 "eval(x1)")
                                (("1"
                                  (inst -1 "eval(x2)")
                                  (("1"
                                    (replaces -)
                                    (("1" (assert) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (hide-all-but 1)
                          (("2" (lemma "eta[real,real]")
                            (("2" (inst -1 "eval(x2)")
                              (("2"
                                (replaces -1)
                                (("2" (assert) nil nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("3" (hide-all-but 1)
                          (("3" (lemma "eta[real,real]")
                            (("3" (inst -1 "eval(x1)")
                              (("3"
                                (replaces -1)
                                (("3" (assert) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("6" (skeep)
          (("6" (expand "dx" 1)
            (("6" (case-replace "POW2_var = 1")
              (("1" (hide -1)
                (("1" (replaces -1)
                  (("1" (expand "eval" 1 2)
                    (("1" (expand "^")
                      (("1" (expand "expt")
                        (("1" (expand "expt")
                          (("1" (lemma "eta[real,real]")
                            (("1" (inst -1 "eval(POW1_var)")
                              (("1" (replaces -1) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (assert)
                (("2" (expand "eval" 2 1)
                  (("2" (expand "eval" 2 1)
                    (("2" (expand "eval" 2 1)
                      (("2" (expand "eval" 2 2)
                        (("2" (expand "eval" 2 3)
                          (("2" (replaces -1)
                            (("2" (lemma "chain_rule[real,real]")
                              (("2"
                                (inst
                                 -1
                                 "eval(POW1_var)"
                                 "LAMBDA(x:real):x^POW2_var")
                                (("1"
                                  (replaces -1)
                                  (("1"
                                    (assert)
                                    (("1"
                                      (lemma "deriv_pow_lam")
                                      (("1"
                                        (inst -1 "POW2_var")
                                        (("1"
                                          (replaces -1)
                                          (("1"
                                            (decompose-equality 2)
                                            (("1"
                                              (expand "*")
                                              (("1" (propax) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("2"
                                  (hide 2 3)
                                  (("2"
                                    (use "derivable_pow_lam")
                                    nil
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (^ const-decl "real" exponentiation nil)
    (expt def-decl "real" exponentiation nil)
    (chain_rule formula-decl nil chain_rule "analysis/")
    (derivable_pow_lam formula-decl nil derivatives_lam "analysis/")
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (deriv_pow_lam formula-decl nil derivatives_lam "analysis/")
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (* const-decl "[T -> real]" real_fun_ops "reals/")
    (POW2_var skolem-const-decl "posnat" poly_expr nil)
    (/= const-decl "boolean" notequal nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (MUL adt-constructor-decl
     "[[PolyExpr, PolyExpr] -> (multiplication?)]" PolyExpr_adt nil)
    (multiplication? adt-recognizer-decl "[PolyExpr -> boolean]"
     PolyExpr_adt nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (x1 skolem-const-decl "PolyExpr" poly_expr nil)
    (x2 skolem-const-decl "PolyExpr" poly_expr nil)
    (deriv_mult_lam formula-decl nil derivatives_lam "analysis/")
    (SUB adt-constructor-decl
     "[[PolyExpr, PolyExpr] -> (subtraction?)]" PolyExpr_adt nil)
    (subtraction? adt-recognizer-decl "[PolyExpr -> boolean]"
     PolyExpr_adt nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (x1_3 skolem-const-decl "PolyExpr" poly_expr nil)
    (x2_4 skolem-const-decl "PolyExpr" poly_expr nil)
    (deriv_sub_lam formula-decl nil derivatives_lam "analysis/")
    (ADD adt-constructor-decl "[[PolyExpr, PolyExpr] -> (addition?)]"
     PolyExpr_adt nil)
    (addition? adt-recognizer-decl "[PolyExpr -> boolean]" PolyExpr_adt
     nil)
    (eta formula-decl nil functions nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (x1_1 skolem-const-decl "PolyExpr" poly_expr nil)
    (x2_2 skolem-const-decl "PolyExpr" poly_expr nil)
    (deriv_add_lam formula-decl nil derivatives_lam "analysis/")
    (X adt-constructor-decl "(variable?)" PolyExpr_adt nil)
    (variable? adt-recognizer-decl "[PolyExpr -> boolean]" PolyExpr_adt
               nil)
    (deriv_id_lam formula-decl nil derivatives_lam "analysis/")
    (deriv_const_lam formula-decl nil derivatives_lam "analysis/")
    (constant? adt-recognizer-decl "[PolyExpr -> boolean]" PolyExpr_adt
               nil)
    (CONST adt-constructor-decl "[real -> (constant?)]" PolyExpr_adt
     nil)
    (PolyExpr_induction formula-decl nil PolyExpr_adt nil)
    (deriv const-decl "[T -> real]" derivatives "analysis/")
    (deriv_fun type-eq-decl nil derivatives "analysis/")
    (derivable? const-decl "bool" derivatives "analysis/")
    (dx def-decl "PolyExpr" poly_expr nil)
    (eval def-decl "real" poly_expr nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (PolyExpr type-decl nil PolyExpr_adt nil)
    (eval_differentiable rec-application-judgement "deriv_fun"
     poly_expr nil)
    (TRUE const-decl "bool" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   shostak)))

